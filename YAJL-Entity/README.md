This library can deserialize JSON data to custom objects. Currently it do has limitations. But it can handle 90% of the situations for you. 

# Setup

From the demo project, drag all files in the group **YAJLizable** and group **aqtoolkit** to your project. Also, in the **Frameworks** group, drag the **YAJLiOS.framework** to your project. And last, in the **Build Settings** of your project, search for a setting called **other linker flags**, add `-ObjC -all_load`, which is required by **YAJLiOS.framework**.

# A Short Demo

The XCode project here is a standard single view controller project. From `YAJLEntityViewController.m`'s `viewDidLoad` we got

```objective-c
NSString *path = [[NSBundle mainBundle] pathForResource:@"data.json" ofType:nil];
NSData *data = [NSData dataWithContentsOfFile:path];
MyEntity *entity = [data objectFromJSONOfType:[MyEntity class]];
```

By looking into the defination of the class MyEntity you can find that it has 2 array properties, one of which contains custom objects while the other contains primitives, and one property of other model class. So this is enough for most of the situations.

# Convention over Configuration

The property's name of the ObjC clas will be mapped to the corresponding one in the json. Conventionally, the names in OjbC are camel-cased, while data from json may be generated by applications like ruby on rails, so it may be snake-cased. YAJL-Entity will handle this for you automatically. If you have a property named `is_admin` in json, you can define this as `isAdmin` in your ObjC class.

This library can also serialize the OjbC class to json string for you. Most of this is provided by YAJL framework. So in order to allow a class to be serialized to json, you have to define a method like

```objective-c
- (id)JSON
{
    return [self dictionaryOfProperyties];
}
```

the `- (id)JSON` method is required by the YAJL framework to serialize the object. It should return the json reprensentation of itself in `NSArray` or `NSDictionary`. The `- (NSDictionary *)dictionaryOfProperty` method is provided by YAJL-Entity which can make a `NSDictionary` containing all the properies and values of this project. Usually, you can have this method in the common parent class of all your models.

For the generated names of the json string's properties, they are same as the ones in the ObjC class. If you want it snake-cased, you can use `- (NSDictionary *)dictionaryOfProperytiesWithOption:` instead.

# To Developers

For the JSON, it lacks any class info. So one of the difficulties is the type inferring. In YAJL-Entity, I look up the obj-c 2.0 declared property info in runtime. I thought it is just a syntactic sugar for declaring getter/setter methods, but it's not. This is kept until runtime. And another thing is the generics in C#/Java. For the objects in an array, we are unable to keep their types either in the obj-c objects or in json objects. For this, I created a 'informal' protocol, a method called initForYAJL. In this method, we just provide the info for the types in arrays, e.g:

```objective-c
- (id)initForYAJL
{
	if ((self = [super initForYAJL])) {
		self.customers = (NSArray *)[Customer class];
	}

	return self;
}
```

YAJL-Entity will use this class object to initialize the instances in the array.

But for the nested arrays, I can do nothing. When facing nested arrays, I parse the json into a NSDictionary/NSArray nested object, which can be done by most json libs in objc. Then I have a helper category method, which can fill the property of an object, with an NSDictionary. It's in `NSObject+FillPropertiesWithDictionary.h`. This can reduce some boilerplate.

